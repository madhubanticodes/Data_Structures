//Code by Madhubanti Mitra
//19/78015

#include <iostream>

using namespace std;

const int size=10;
int flag=0;
int leaf=0;
int non_leaf=0;

class Node
{
    public:
     int data;
     Node *left;
     Node *right;
};

Node *root=NULL;

class stack
{
    Node *s[size],*n;
    int top;
    public:
     stack()
     {
         top=-1;
     }
     void push(Node*);
     Node* pop();
     int isempty();
     int isfull();
};

void stack::push(Node* ele)
{
    if(isfull())
    {
        cout<<"\nStack is full";
    }
    else
    {
        top++;
        s[top]=ele;
    }
}

Node* stack::pop()
{
    if(isempty())
    {
        cout<<"\nNo element to pop";
        n=0;
    }
    else
    {
        n=s[top];
        top--;
    }
    return n;
}

int stack::isempty()
{
    if(top==-1)
      return 1;
    else
      return 0;
}

int stack::isfull()
{
    if(top==size-1)
      return 1;
    else
      return 0;
}

class queue
{
    Node *q[size],*n;
    int front,rear;
    public:
      queue()
       {
         front=rear=-1;
       }
         void enqueue(Node*);
         Node* dequeue();
         int isempty();
         int isfull();
};

void queue::enqueue(Node *ele)
{
    if(isfull())
    {
        cout<<"\nQueue is full";
    }
    else if(rear==-1)
    {
        front=rear=0;
    }
    else if(rear==size-1&&front>0)
    {
        rear=0;
    }
    else
    {
        rear++;
    }
        q[rear]=ele;
}

Node* queue::dequeue()
{
    if(isempty())
    {
        cout<<"\nQueue is empty, nothing to delete";
        n=0;
    }
    else
    {
        n=q[front];
        if(front==rear)
        {
            front=rear=-1;
        }
        else if(front==size-1)
        {
            front=0;
        }
        else
        {
            front++;
        }
    }
    return n;
}

int queue::isempty()
{
    return (front==-1&&rear==-1);
}

int queue::isfull()
{
    return ((front==0&&rear==size-1)||front==rear+1);
}

class Bst
{
    Node *a,*b,*c;
    public:
        void insert();
        void searching(Node*,int);
        void recursive_inorder(Node*);
        void recursive_preorder(Node *);
        void recursive_postorder(Node*);
        //void iterative_inorder(Node*);
        void iterative_preorder(Node*);
        //void iterative_postorder(Node*);
        void bfs_traversal(Node*);
        void mirror_image(Node*);
        void Count(Node*);
};

void Bst::insert()
{
    int i;
    cout<<"\nEnter values for bst and 0 to exit:";
    cin>>i;
    while(i!=0)
    {
       if(root==NULL)
       {
           root=new Node();
           root->left=0;
           root->right=0;
           root->data=i;
       }
       else
       {
           a=root;
           b=new Node();
           b->left=0;
           b->right=0;
           b->data=i;
           while(a!=0)
           {
               if(i<a->data)
               {
                   c=a;
                   a=a->left;
               }
               else
               {
                   if(i>=a->data)
                   {
                       c=a;
                       a=a->right;
                   }
               }
           }
           if(i<c->data)
           {
               c->left=b;
           }
           else
           {
               c->right=b;
           }
       }
       cout<<"\nEnter values for bst and 0 to exit:";
       cin>>i;
    }
}

void Bst::recursive_inorder(Node *temp)
{
    if(temp!=0)
    {
        recursive_inorder(temp->left);
        cout<<temp->data<<" ";
        recursive_inorder(temp->right);
    }
}

void Bst::recursive_preorder(Node *temp)
{
    if(temp!=NULL)
    {
        cout<<temp->data<<" ";
        recursive_preorder(temp->left);
        recursive_preorder(temp->right);
    }

}

void Bst::recursive_postorder(Node *temp)
{
    if(temp!=0)
    {
        recursive_postorder(temp->left);
        recursive_postorder(temp->right);
        cout<<temp->data<<" ";
    }
}

void Bst::bfs_traversal(Node *temp)
{
    queue q;
    if(temp!=0)
    {
        q.enqueue(temp);
        while(!q.isempty())
        {
            temp=q.dequeue();
            cout<<" "<<temp->data;
            if(temp->left!=0)
            {
                q.enqueue(temp->left);
            }
            if(temp->right!=0)
            {
                q.enqueue(temp->right);
            }
        }
    }
}

void Bst::Count(Node *temp)
{
    if(temp!=NULL)
    {
        if(temp->left!=NULL||temp->right!=NULL)
           non_leaf++;
        if(temp->left==NULL&&temp->right==NULL)
           leaf++;
        Count(temp->left);
        Count(temp->right);
    }

}



void Bst::iterative_preorder(Node *temp)
{
    stack s;
    if(temp!=0)
    {
        s.push(temp);
        while(!s.isempty())
        {
            temp=s.pop();
            cout<<" "<<temp->data;
            if(temp->right!=0)
            {
                s.push(temp->right);
            }
            if(temp->left!=0)
            {
                s.push(temp->left);
            }
        }
    }
}

void   Bst::searching(Node* temp, int data){
   while (temp != NULL )
   {
       if(temp->data == data)
      {flag=1;
      break;}
      else if(data<temp->data)
        temp=temp->left;
      else
        temp=temp->right;}
   }

void Bst::mirror_image(Node* temp)
{
  if (temp != 0)
    {
        Node* temp1;
        mirror_image(temp->left);
        mirror_image(temp->right);
        temp1 = temp->left;
        temp->left  = temp->right;
        temp->right = temp1;

    }
}
int main()
{
    Bst b;
    int choice,n;
    do
    {
        cout<<"\n-------------BST---------------\n";
        cout<<"1) Insert                   "
            <<"2) recursive_inorder        3) recursive_preorder\n"
            <<"4) recursive_postorder      5) bfs Traversal\n"
            <<"6) Count                    7) iterative_preorder\n"
            <<"8) Search a Node            9) Mirror Image\n";
        cout<<"\nEnter your choice:";
        cin>>choice;
        switch(choice)
        {
            case 1:
              b.insert();
              break;
            case 2:
              b.recursive_inorder(root);
              break;
            case 3:
                b.recursive_preorder(root);
                break;
            case 4:
                b.recursive_postorder(root);
                break;
            case 5:
                b.bfs_traversal(root);
                break;
            case 6:
                b.Count(root);
                cout<<"No. of non-leafs: "<<non_leaf;
                cout<<"\nNo. of leafs: "<<leaf;
                cout<<"\nTotal no. of leafs: "<<non_leaf+leaf;
                break;
            case 7:
                b.iterative_preorder(root);
                break;
            case 8:
                cout<<"\nEnter element to be searched: ";
                cin>>n;
                b.searching(root,n);
                if(flag==1)
                    cout<<"Found";
                else
                    cout<<"\nNot Found";
                break;
            case 9:
                b.mirror_image(root);
                break;
            default:
              break;
        }
    }while(choice!=0);
}
